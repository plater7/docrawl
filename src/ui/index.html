<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docrawl</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            min-height: 100vh;
            padding: 2rem;
        }
        .container { max-width: 800px; margin: 0 auto; }
        h1 { margin-bottom: 1.5rem; color: #f8fafc; }
        .form-group { margin-bottom: 1rem; }
        label {
            display: block;
            margin-bottom: 0.5rem;
            color: #94a3b8;
            font-size: 0.875rem;
        }
        input, select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #334155;
            border-radius: 0.5rem;
            background: #1e293b;
            color: #e2e8f0;
            font-size: 1rem;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #3b82f6;
        }
        .row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .checkbox-group input { width: auto; }
        .buttons { display: flex; gap: 1rem; margin-top: 1.5rem; }
        button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn-primary {
            background: #3b82f6;
            color: white;
        }
        .btn-primary:hover { background: #2563eb; }
        .btn-primary:disabled {
            background: #475569;
            cursor: not-allowed;
        }
        .btn-danger {
            background: #ef4444;
            color: white;
            display: none;
        }
        .btn-danger:hover { background: #dc2626; }
        .log {
            margin-top: 2rem;
            padding: 1rem;
            background: #1e293b;
            border-radius: 0.5rem;
            font-family: monospace;
            font-size: 0.875rem;
            max-height: 400px;
            overflow-y: auto;
        }
        .log-entry { padding: 0.25rem 0; border-bottom: 1px solid #334155; }
        .log-entry.error { color: #f87171; }
        .log-entry.success { color: #4ade80; }
        .log-entry.info { color: #60a5fa; }
        .summary {
            margin-top: 1rem;
            padding: 1rem;
            background: #1e293b;
            border-radius: 0.5rem;
            display: none;
        }
        .summary h3 { margin-bottom: 0.5rem; }
        .stat { display: inline-block; margin-right: 1.5rem; }
        .stat-value { font-size: 1.5rem; font-weight: bold; color: #3b82f6; }
        .models-section {
            margin-bottom: 1rem;
            border: 1px solid #334155;
            border-radius: 0.5rem;
            padding: 1rem;
            background: #1a2332;
        }
        .section-label {
            display: block;
            color: #e2e8f0;
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
        }
        .model-row {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        .model-row:last-child { margin-bottom: 0; }
        .model-select {
            flex: 1;
            min-width: 0;
        }
        .model-select label {
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
        }
        .model-hint {
            flex: 0 0 auto;
            max-width: 280px;
            display: flex;
            align-items: flex-start;
            gap: 0.35rem;
            padding-top: 1.5rem;
            font-size: 0.75rem;
            color: #64748b;
            line-height: 1.3;
        }
        .hint-icon {
            color: #475569;
            flex-shrink: 0;
        }
        @media (max-width: 640px) {
            .model-row { flex-direction: column; }
            .model-hint { padding-top: 0; max-width: 100%; }
        }

        /* Phase banner */
        .phase-banner {
            margin-top: 2rem;
            margin-bottom: 0;
            padding: 0.6rem 1rem;
            background: #1e293b;
            border: 1px solid #334155;
            border-bottom: none;
            border-radius: 0.5rem 0.5rem 0 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: monospace;
            font-size: 0.85rem;
        }
        .phase-banner + .log {
            margin-top: 0;
            border-radius: 0 0 0.5rem 0.5rem;
            border-top: 1px solid #334155;
        }
        .phase-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #3b82f6;
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .phase-name {
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .phase-separator { color: #475569; }
        .phase-detail { color: #94a3b8; }

        /* Phase colors */
        .phase-init .phase-name, .phase-init .phase-dot { color: #94a3b8; background: #94a3b8; }
        .phase-init .phase-name { background: none; }
        .phase-discovery .phase-name { color: #f59e0b; }
        .phase-discovery .phase-dot { background: #f59e0b; }
        .phase-filtering .phase-name { color: #8b5cf6; }
        .phase-filtering .phase-dot { background: #8b5cf6; }
        .phase-scraping .phase-name { color: #3b82f6; }
        .phase-scraping .phase-dot { background: #3b82f6; }
        .phase-cleanup .phase-name { color: #06b6d4; }
        .phase-cleanup .phase-dot { background: #06b6d4; }
        .phase-save .phase-name { color: #10b981; }
        .phase-save .phase-dot { background: #10b981; }
        .phase-done .phase-name { color: #4ade80; }
        .phase-done .phase-dot { background: #4ade80; animation: none; }
        .phase-failed .phase-name { color: #ef4444; }
        .phase-failed .phase-dot { background: #ef4444; animation: none; }
        .phase-cancelled .phase-name { color: #f97316; }
        .phase-cancelled .phase-dot { background: #f97316; animation: none; }

        /* Log badges */
        .log-badge {
            display: inline-block;
            padding: 0.05rem 0.4rem;
            border-radius: 0.2rem;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-right: 0.4rem;
            min-width: 65px;
            text-align: center;
        }
        .badge-init { background: #1e293b; color: #94a3b8; border: 1px solid #475569; }
        .badge-discovery { background: #451a03; color: #fbbf24; }
        .badge-filtering { background: #2e1065; color: #a78bfa; }
        .badge-scraping { background: #172554; color: #60a5fa; }
        .badge-cleanup { background: #083344; color: #22d3ee; }
        .badge-save { background: #022c22; color: #34d399; }
        .badge-done { background: #052e16; color: #4ade80; }
        .badge-failed { background: #450a0a; color: #f87171; }

        .log-model {
            color: #64748b;
            font-size: 0.75rem;
        }
        .log-entry.warning { color: #fbbf24; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Docrawl</h1>

        <form id="crawlForm">
            <div class="form-group">
                <label for="url">Documentation URL</label>
                <input type="url" id="url" required placeholder="https://docs.example.com">
            </div>

            <div class="models-section">
                <label class="section-label">Ollama Models</label>

                <div class="model-row">
                    <div class="model-select">
                        <label for="crawlModel">Crawl Model</label>
                        <select id="crawlModel" required>
                            <option value="">Loading models...</option>
                        </select>
                    </div>
                    <div class="model-hint">
                        <span class="hint-icon">&#8505;</span>
                        <span class="hint-text">URL discovery & filtering. Priorizar velocidad.<br>Ej: mistral:7b, llama3.2:3b, qwen3:14b</span>
                    </div>
                </div>

                <div class="model-row">
                    <div class="model-select">
                        <label for="pipelineModel">Pipeline Model</label>
                        <select id="pipelineModel" required>
                            <option value="">Loading models...</option>
                        </select>
                    </div>
                    <div class="model-hint">
                        <span class="hint-icon">&#8505;</span>
                        <span class="hint-text">Markdown cleanup por chunks. Balance velocidad/calidad.<br>Ej: qwen3:14b, mistral:7b, llama3.1:8b</span>
                    </div>
                </div>

                <div class="model-row">
                    <div class="model-select">
                        <label for="reasoningModel">Reasoning Model</label>
                        <select id="reasoningModel" required>
                            <option value="">Loading models...</option>
                        </select>
                    </div>
                    <div class="model-hint">
                        <span class="hint-icon">&#8505;</span>
                        <span class="hint-text">Analisis de estructura y filtrado complejo. Maxima calidad.<br>Ej: deepseek-r1:32b, qwen3:14b, kimi-k2.5</span>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label for="outputPath">Output Path <span style="color:#64748b;font-size:0.75rem;">(auto-generated from URL)</span></label>
                <input type="text" id="outputPath" value="/data/output">
            </div>

            <div class="row">
                <div class="form-group">
                    <label for="delayMs">Delay between requests (ms)</label>
                    <input type="number" id="delayMs" value="500" min="0">
                </div>
                <div class="form-group">
                    <label for="maxConcurrent">Max concurrent pages</label>
                    <input type="number" id="maxConcurrent" value="3" min="1" max="10">
                </div>
            </div>

            <div class="row">
                <div class="form-group">
                    <label for="maxDepth">Max crawl depth</label>
                    <input type="number" id="maxDepth" value="5" min="1" max="20">
                </div>
                <div class="form-group checkbox-group" style="align-self: end; padding-bottom: 0.75rem;">
                    <input type="checkbox" id="respectRobots" checked>
                    <label for="respectRobots" style="margin: 0;">Respect robots.txt</label>
                </div>
            </div>

            <div class="buttons">
                <button type="submit" class="btn-primary" id="startBtn">Start Crawl</button>
                <button type="button" class="btn-danger" id="cancelBtn">Cancel</button>
            </div>
        </form>

        <div class="phase-banner" id="phaseBanner" style="display:none;">
            <span class="phase-dot" id="phaseDot"></span>
            <span class="phase-name" id="phaseName">INIT</span>
            <span class="phase-separator">·</span>
            <span class="phase-detail" id="phaseDetail"></span>
        </div>
        <div class="log" id="log"></div>

        <div class="summary" id="summary">
            <h3>Results</h3>
            <div>
                <span class="stat"><span class="stat-value" id="pagesOk">0</span> OK</span>
                <span class="stat"><span class="stat-value" id="pagesPartial">0</span> Partial</span>
                <span class="stat"><span class="stat-value" id="pagesFailed">0</span> Failed</span>
            </div>
        </div>
    </div>

    <script>
        const form = document.getElementById('crawlForm');
        const startBtn = document.getElementById('startBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const logDiv = document.getElementById('log');
        const summaryDiv = document.getElementById('summary');
        const phaseBanner = document.getElementById('phaseBanner');
        const phaseDot = document.getElementById('phaseDot');
        const phaseName = document.getElementById('phaseName');
        const phaseDetail = document.getElementById('phaseDetail');

        const crawlModelSelect = document.getElementById('crawlModel');
        const pipelineModelSelect = document.getElementById('pipelineModel');
        const reasoningModelSelect = document.getElementById('reasoningModel');

        let currentJobId = null;
        let eventSource = null;

        async function loadModels() {
            const selects = [crawlModelSelect, pipelineModelSelect, reasoningModelSelect];
            try {
                const res = await fetch('/api/models');
                const models = await res.json();
                const optionsHtml = models.length
                    ? models.map(m => `<option value="${m.name}">${m.name}</option>`).join('')
                    : '<option value="">No models available</option>';
                selects.forEach(s => s.innerHTML = optionsHtml);
            } catch (e) {
                selects.forEach(s => s.innerHTML = '<option value="">Error loading models</option>');
                logMessage('Failed to load Ollama models', 'init', 'error');
            }
        }

        function updateOutputPath() {
            const urlInput = document.getElementById('url').value.trim();
            if (!urlInput) {
                document.getElementById('outputPath').value = '/data/output';
                return;
            }
            try {
                const parsed = new URL(urlInput);
                let domain = parsed.hostname.replace(/^(www|docs|doc|documentation|wiki)\./i, '');
                let section = parsed.pathname
                    .replace(/\/$/, '')
                    .replace(/^\/(latest|stable|v\d[^/]*)/i, '')
                    .replace(/^\/docs?\/?/i, '')
                    .replace(/^\//, '');
                let outputPath = `/data/output/${domain}`;
                if (section) {
                    const parts = section.split('/').filter(Boolean);
                    if (parts.length > 3) {
                        section = parts[0] + '/' + parts[parts.length - 1];
                    } else {
                        section = parts.join('/');
                    }
                    outputPath += `/${section}`;
                }
                document.getElementById('outputPath').value = outputPath;
            } catch (e) { /* URL not valid yet */ }
        }

        function updatePhaseBanner(phase, detail) {
            phaseBanner.style.display = 'flex';
            phaseBanner.className = `phase-banner phase-${phase}`;
            phaseName.textContent = phase;
            phaseDetail.textContent = detail || '';
        }

        function hidePhaseBanner() {
            phaseBanner.style.display = 'none';
        }

        function logMessage(message, phase, level) {
            const entry = document.createElement('div');
            const levelClass = level === 'error' ? 'error' : level === 'warning' ? 'warning' : level === 'success' ? 'success' : '';
            entry.className = `log-entry ${levelClass}`;

            const time = new Date().toLocaleTimeString();
            const badgeClass = phase ? `badge-${phase}` : '';
            const badge = phase ? `<span class="log-badge ${badgeClass}">${phase}</span>` : '';

            entry.innerHTML = `<span style="color:#475569">[${time}]</span> ${badge}${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function setRunning(running) {
            startBtn.disabled = running;
            cancelBtn.style.display = running ? 'block' : 'none';
            if (!running) hidePhaseBanner();
        }

        async function startCrawl(e) {
            e.preventDefault();
            logDiv.innerHTML = '';
            summaryDiv.style.display = 'none';

            const payload = {
                url: document.getElementById('url').value,
                crawl_model: crawlModelSelect.value,
                pipeline_model: pipelineModelSelect.value,
                reasoning_model: reasoningModelSelect.value,
                output_path: document.getElementById('outputPath').value,
                delay_ms: parseInt(document.getElementById('delayMs').value),
                max_concurrent: parseInt(document.getElementById('maxConcurrent').value),
                max_depth: parseInt(document.getElementById('maxDepth').value),
                respect_robots_txt: document.getElementById('respectRobots').checked,
            };

            try {
                const res = await fetch('/api/jobs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const job = await res.json();
                currentJobId = job.id;
                logMessage(`Job started: ${job.id}`, 'init', 'info');
                setRunning(true);
                subscribeToEvents(job.id);
            } catch (e) {
                logMessage(`Failed to start job: ${e.message}`, 'init', 'error');
            }
        }

        function subscribeToEvents(jobId) {
            eventSource = new EventSource(`/api/jobs/${jobId}/events`);

            // Phase change — updates the banner
            eventSource.addEventListener('phase_change', (e) => {
                const data = JSON.parse(e.data);
                let detail = data.message || '';
                if (data.active_model) detail += ` · ${data.active_model}`;
                if (data.progress) detail += ` · ${data.progress}`;
                updatePhaseBanner(data.phase, detail);
            });

            // General log entries — go to the log panel with badges
            eventSource.addEventListener('log', (e) => {
                const data = JSON.parse(e.data);
                let msg = data.message;
                if (data.active_model) {
                    msg += ` <span class="log-model">[${data.active_model}]</span>`;
                }
                logMessage(msg, data.phase, data.level || '');
            });

            // Backwards compat with legacy event types
            eventSource.addEventListener('discovery', (e) => {
                const data = JSON.parse(e.data);
                logMessage(`${data.phase} - ${data.status || ''} ${data.urls_found ? `(${data.urls_found} URLs)` : ''}`, 'discovery');
            });

            eventSource.addEventListener('filtering', (e) => {
                const data = JSON.parse(e.data);
                logMessage(`${data.phase} ${data.after_basic ? `(${data.after_basic} URLs)` : ''} ${data.after_llm ? `→ ${data.after_llm} URLs` : ''}`, 'filtering');
            });

            eventSource.addEventListener('page_start', (e) => {
                const data = JSON.parse(e.data);
                logMessage(`[${data.index}/${data.total}] Loading: ${data.url}`, 'scraping', 'info');
            });

            eventSource.addEventListener('page_done', (e) => {
                const data = JSON.parse(e.data);
                const msg = data.chunks_failed > 0
                    ? `Done (${data.chunks_failed}/${data.chunks_total} chunks failed)`
                    : '✓ Done';
                logMessage(`  → ${msg}`, 'save', data.status === 'ok' ? 'success' : 'warning');
            });

            eventSource.addEventListener('page_error', (e) => {
                const data = JSON.parse(e.data);
                logMessage(`  → Error: ${data.error}`, 'scraping', 'error');
            });

            eventSource.addEventListener('job_done', (e) => {
                const data = JSON.parse(e.data);
                if (data.status === 'completed') {
                    updatePhaseBanner('done', `Output: ${data.output_path}`);
                    logMessage(`Job completed! ${data.pages_ok} OK, ${data.pages_partial || 0} partial, ${data.pages_failed || 0} failed`, 'done', 'success');
                } else {
                    updatePhaseBanner('failed', data.error || 'Unknown error');
                    logMessage(`Job failed: ${data.error}`, 'failed', 'error');
                }
                showSummary(data);
                cleanupJob();
            });

            eventSource.addEventListener('job_cancelled', (e) => {
                const data = JSON.parse(e.data);
                updatePhaseBanner('cancelled', `${data.pages_completed}/${data.pages_total} pages processed`);
                logMessage(`Job cancelled. Processed ${data.pages_completed}/${data.pages_total} pages.`, 'cancelled');
                cleanupJob();
            });

            // Silently consume keepalive events
            eventSource.addEventListener('keepalive', () => {});

            eventSource.onerror = (e) => {
                if (!currentJobId) return;

                // Close dead EventSource
                if (eventSource) {
                    eventSource.close();
                    eventSource = null;
                }

                // Check if job is still running before giving up
                fetch(`/api/jobs/${currentJobId}/status`)
                    .then(r => {
                        if (!r.ok) throw new Error(`Status ${r.status}`);
                        return r.json();
                    })
                    .then(status => {
                        if (status.status === 'running' || status.status === 'pending') {
                            logMessage('SSE reconnecting...', 'init', 'warning');
                            setTimeout(() => {
                                if (currentJobId) subscribeToEvents(currentJobId);
                            }, 2000);
                        } else if (status.status === 'completed') {
                            updatePhaseBanner('done', 'Completed');
                            logMessage('Job completed.', 'done');
                            cleanupJob();
                        } else if (status.status === 'cancelled') {
                            updatePhaseBanner('cancelled', `${status.pages_completed}/${status.pages_total} pages`);
                            logMessage(`Cancelled. ${status.pages_completed}/${status.pages_total} pages processed.`, 'cancelled');
                            cleanupJob();
                        } else {
                            logMessage('Job failed.', 'failed', 'error');
                            cleanupJob();
                        }
                    })
                    .catch(() => {
                        // Server might be restarting — retry once after 5s
                        setTimeout(() => {
                            if (!currentJobId) return;
                            fetch(`/api/jobs/${currentJobId}/status`)
                                .then(r => r.ok ? r.json() : Promise.reject())
                                .then(status => {
                                    if (status.status === 'running') {
                                        subscribeToEvents(currentJobId);
                                    } else {
                                        logMessage('Connection lost', 'failed', 'error');
                                        cleanupJob();
                                    }
                                })
                                .catch(() => {
                                    logMessage('Connection lost — server may have restarted', 'failed', 'error');
                                    cleanupJob();
                                });
                        }, 5000);
                    });
            };
        }

        async function cancelJob() {
            if (!currentJobId) return;
            try {
                await fetch(`/api/jobs/${currentJobId}/cancel`, { method: 'POST' });
                logMessage('Cancelling...', 'init', 'info');
            } catch (e) {
                logMessage(`Failed to cancel: ${e.message}`, 'init', 'error');
            }
        }

        function showSummary(data) {
            document.getElementById('pagesOk').textContent = data.pages_ok || 0;
            document.getElementById('pagesPartial').textContent = data.pages_partial || 0;
            document.getElementById('pagesFailed').textContent = data.pages_failed || 0;
            summaryDiv.style.display = 'block';
        }

        function cleanupJob() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            currentJobId = null;
            setRunning(false);
            // Keep banner visible showing terminal state (done/failed/cancelled)
        }

        document.getElementById('url').addEventListener('input', updateOutputPath);
        form.addEventListener('submit', startCrawl);
        cancelBtn.addEventListener('click', cancelJob);
        loadModels();
    </script>
</body>
</html>
